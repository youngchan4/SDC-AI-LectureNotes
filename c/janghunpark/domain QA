1. 코드의 확장성 극대화, 유지 및 보수 용이성 극대화, Agile한 작업에 최적화
하나의 domain에 문제가 생겨도 다른 domain에 가는 영향이 적음 
2. 특정 object에 관심이 집중되어 있으며, 이로 인해 다른 domain의 관심사와 분리되어있는 영역
내가 관심이 있는 주제
3. 특정 기능의 구동에 대해 폭포수식 설계로 이어나가다가 전체가 망가질 수 있는 lisk를 최소화하기 위해,
해당 기능이 목적에 부합하게 작동하는지 판단하기 위함
테스트가 일부러 실패하도록 만듦으로써 일단 추상화(세부사항을 제외하고)
최종적으로 DDD를 효율적으로 구현하기 위함
4. 세부사항을 먼저 보지 않음으로써 추후 backlog를 작성할 때 용이, 해당 기능의 정확한 용도 파악 가능
5. 다른 사람이 해당 자료를 검토할 때 팀이 어떤 목적성으로 작업을 했는지 명확히 알 수 없음
(따라서 backlog에는 반드시 누가 어떤 목적으로 무엇을 하는지를 명시해야 함)
6. 동시 다발적으로 여러 작업단위가 한 번에 묶여 backlog가 작성되고, 이 경우 추후 코드 수정사항이 발생할 때
이전 commit에서 어느 작업이 문제인지 파악하기 매우 어려워 짐 (commit된 모든 파일을 검토해야 하는 비효율 초래)
7. agile한 프로세스 진행 자체가 어려움. backlog가 작성되어 있을 시 해당 작업을 팀이 all-for-one기조에 
맞게 유기적으로 작업할 수 있지만, 그렇지 않을 경우 작업을 일일이 재검토해야 하는 비효율 초래
8. 함수 포인터 배열을 통해 해당 domain에서 구현해야 하는 기능들이 case에 따라 분리가 되며 자연스럽게 DDD 목적성에 맞는 코드 구현 가능
inversion of control = 함수 의존성을 낮춤으로써 하나가 터졌을 때 연쇄적인 파급을 방지할 수 있음(IOC layer)
9. 사용자로부터 받은 요청과 서버에서 돌아오는 응답, entity(업무, 비즈니스를 할 때 핵심 단위체)에 행하는 action, repo는 세부사항이 어디에 배치될 것인가(placement)
10. 동일한 문제가 개인에게 발생할 경우, 처음부터 알아봐야 하는 비효율 초래
만약 slack을 지속적으로 확인했다면 어떤 채널에서 빠르게 issue에 대응할 수 있는 방법을 찾음으로써 작업 효율을 
높일 수 있음

백로그는 결국 큰 흐름, slack에 올라오는 것은 작업 세부내용을 확인
